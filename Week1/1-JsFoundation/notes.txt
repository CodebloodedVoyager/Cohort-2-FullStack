Day 2: 7th Sept, 2025
Slides: https://100x-b-mcdn.akamai.net.in/cohort-2-slides/week+1.2.pdf



Week: 1.2 Javascript Foundation
==============================  INDEX ========================

1. Why Languages
2. Interpreted vs Compiled Languages
3. Why Js >> Other Languages
4. Strickt vs Dynamic Languages
5. Sigle Threaded nature of Js.
6. Simple Primitives in Js (Number, String, booleans)
7. Complex Primitives in Js (Arrays, Objects)
8. Functions in Javascript
9. Practice Problem Solving
10. Callback Functions, Event Loops, Callbacks
11. Call Backhell and Promises.

==============================================================
ðŸ“˜ JavaScript Foundations (Week 1.2)

1. Why Languages?
Human â†” Machine bridge.
High-level â†’ Easy for humans, machine translates it to low-level (binary).

2. Interpreted vs Compiled
Compiled: Entire code converted to machine code before execution (e.g., C, C++). Faster runtime.
Interpreted: Line-by-line execution (e.g., JavaScript, Python). Easier debugging, slower runtime.
0S: Interpreted but modern engines (V8) use JIT (Just-in-Time) compilation for speed.

3. Why JS >> Other Languages?
Runs directly in browser (client-side).
Huge ecosystem (Node.js â†’ backend, React/Angular â†’ frontend).
Universal: One language for Frontend + Backend.
Asynchronous handling (Event loop).

4. Strict vs Dynamic Languages
Strictly typed: Variable types fixed (e.g., Java int a = 5).
Dynamic typed: Type decided at runtime (JS: let a = 5; a = "hello";).
JS â†’ Dynamic.

5. Single-threaded Nature of JS
JS executes in one thread (one task at a time).
Uses Event Loop + Callbacks to manage async tasks.
Non-blocking I/O makes it powerful despite single-threading.

6. Simple Primitives
Numbers â†’ let x = "anyVariable"; var y = "canChange", const = "cantChange"
Strings â†’ "hello"
Stored as immutable values.

7. Complex Primitives
Arrays: Ordered list â†’ [1,2,3]
Objects: Key-value pairs â†’ {name: "Bhawesh", age: 21}
Stored as references.

8. Functions in JS
First-class citizens â†’ Can be stored in variables, passed as args, returned.

function greet() { return "Hi"; }
let f = greet; f();

9. Callback Functions
Function passed to another function to be executed later.
function sum(a, b, callback) {
  callback(a + b);
}
sum(2, 3, console.log); // 5

10. Event Loop
Manages sync + async tasks.
Call stack â†’ executes functions.
Async tasks go to callback queue, event loop pushes them back to stack when ready.

11. Callback Hell
Too many nested callbacks â†’ unreadable code.

setTimeout(() => {
  setTimeout(() => {
    setTimeout(() => {
      console.log("Hell!");
    }, 1000);
  }, 1000);
}, 1000);

12. Promises
Cleaner way to handle async.

fetch(url)
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err));


States: pending â†’ fulfilled â†’ rejected.
==============================================================



======== New Terms ==========
Threads & Cores in PC Machine, Single Threaded, Context Switching, Cluster Module
=========================